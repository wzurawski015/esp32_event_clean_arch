diff --git a/README.md b/README.md
index 0f39429..5901ec7 100644
--- a/README.md
+++ b/README.md
@@ -139,7 +139,7 @@ Wybrane komponenty (prefiks = warstwa):
 - `components/ports` — „czyste” interfejsy (np. I²C).
 - `components/infrastructure__idf_i2c_port` — adapter nowego I²C (`driver/i2c_master.h`).
 - `components/services__i2c` — asynchroniczny worker I²C (`EV_I2C_DONE`).
-- `components/services__timer` — `EV_TICK_100MS`, `EV_TICK_1S` na `esp_timer`.
+- `components/services__timer` — deadline-driven timer: uzbraja najbliższy deadline i publikuje zdarzenia; opcjonalnie (Kconfig) generuje legacy `EV_TICK_*`.
 - `components/drivers__lcd1602rgb_dfr_async` — DFR0464 (ST7032 + PCA9633) jako FSM, bez blokad; parametry przez Kconfig.
 - `components/services__ds18b20_ev` — asynchroniczny DS18B20 (tryb one‑shot).
 
diff --git a/firmware/components/app__demo_lcd/app_demo_lcd.c b/firmware/components/app__demo_lcd/app_demo_lcd.c
index 3289dfc..df838f5 100644
--- a/firmware/components/app__demo_lcd/app_demo_lcd.c
+++ b/firmware/components/app__demo_lcd/app_demo_lcd.c
@@ -99,11 +99,6 @@ static void app_demo_lcd_task(void* arg)
             continue;
         }
 
-        // 3) Diagnostyczne „tyknięcie”
-        if (m.src == EV_SRC_TIMER && m.code == EV_TICK_1S) {
-            LOGD(TAG, "[%u ms] tick", (unsigned)m.t_ms);
-            continue;
-        }
     }
 }
 
diff --git a/firmware/components/core__ev/include/core_ev_schema.h b/firmware/components/core__ev/include/core_ev_schema.h
index a76a50f..6ccd669 100644
--- a/firmware/components/core__ev/include/core_ev_schema.h
+++ b/firmware/components/core__ev/include/core_ev_schema.h
@@ -19,8 +19,8 @@
     X(EV_SYS_START,        EV_SRC_SYS,   0x0001, NONE,  DROP_NEW,     EVF_CRITICAL, "start systemu") \
     \
     /* TIMER */ \
-    X(EV_TICK_100MS,       EV_SRC_TIMER, 0x1000, NONE,  DROP_NEW,     0,           "tick 100ms") \
-    X(EV_TICK_1S,          EV_SRC_TIMER, 0x1001, NONE,  DROP_NEW,     0,           "tick 1s") \
+    X(EV_TICK_100MS,       EV_SRC_TIMER, 0x1000, NONE,  DROP_NEW,     0,           "tick 100ms (legacy; domyślnie OFF)") \
+    X(EV_TICK_1S,          EV_SRC_TIMER, 0x1001, NONE,  DROP_NEW,     0,           "tick 1s (legacy; domyślnie OFF)") \
     \
     /* I2C */ \
     X(EV_I2C_DONE,         EV_SRC_I2C,   0x2000, COPY,  DROP_NEW,     0,           "I2C done: a0=user, a1=0") \
diff --git a/firmware/components/services__timer/CMakeLists.txt b/firmware/components/services__timer/CMakeLists.txt
index b6b1af9..f09f7de 100644
--- a/firmware/components/services__timer/CMakeLists.txt
+++ b/firmware/components/services__timer/CMakeLists.txt
@@ -1,5 +1,5 @@
 idf_component_register(
   SRCS "services_timer.c"
   INCLUDE_DIRS "include"
-  REQUIRES core__ev esp_timer
+  REQUIRES core__ev ports infrastructure__idf_timer_port infrastructure__idf_clock_port
 )
diff --git a/firmware/components/services__timer/Kconfig b/firmware/components/services__timer/Kconfig
new file mode 100644
index 0000000..8d46458
--- /dev/null
+++ b/firmware/components/services__timer/Kconfig
@@ -0,0 +1,19 @@
+menu "Services: deadline timer"
+
+config SERVICES_TIMER_MAX_SLOTS
+    int "Max. liczba aktywnych deadline'ów"
+    range 4 64
+    default 16
+    help
+        Maksymalna liczba równocześnie uzbrojonych timerów (deadline'ów)
+        utrzymywanych przez komponent services__timer.
+
+config SERVICES_TIMER_ENABLE_LEGACY_TICKS
+    bool "(Legacy) Generuj EV_TICK_100MS / EV_TICK_1S automatycznie"
+    default n
+    help
+        Jeśli włączone, services__timer po starcie uzbraja dwa periodyczne timery
+        i publikuje EV_TICK_100MS oraz EV_TICK_1S (zachowanie jak w starszych wersjach).
+        Domyślnie wyłączone — preferowane jest explicit armowanie deadline'ów.
+
+endmenu
diff --git a/firmware/components/services__timer/include/services_timer.h b/firmware/components/services__timer/include/services_timer.h
index d330a26..08a2338 100644
--- a/firmware/components/services__timer/include/services_timer.h
+++ b/firmware/components/services__timer/include/services_timer.h
@@ -1,21 +1,82 @@
 /**
  * @file services_timer.h
- * @brief Serwis zegarów – generuje EV_TICK_100MS i EV_TICK_1S z użyciem esp_timer.
+ * @brief Serwis timerów deadline-driven (one-shot / periodic) emitujący zdarzenia na EV-bus.
+ *
+ * Zamiast globalnych "ticków" (spam), serwis trzyma listę aktywnych deadline'ów i uzbraja
+ * tylko najbliższy. Po wygaśnięciu publikuje wskazane zdarzenie (ev_post).
+ *
+ * Funkcje API są przeznaczone do użycia w kontekście taska (nie ISR).
  */
 #pragma once
+
 #include <stdbool.h>
+#include <stdint.h>
+
+#include "core_ev.h"
 
 #ifdef __cplusplus
-extern "C"
-{
+extern "C" {
 #endif
 
-    /** Inicjalizacja serwisu zegarów. */
-    bool services_timer_start(void);
+/**
+ * Token (handle) timera.
+ *
+ * - 0 == nieprawidłowy / błąd
+ * - pozostałe wartości są stabilne do czasu anulowania / wygaśnięcia
+ */
+typedef uint32_t services_timer_token_t;
 
-    /** Zatrzymanie (opcjonalne). */
-    void services_timer_stop(void);
+/**
+ * Uruchamia serwis timerów.
+ *
+ * @return true jeśli serwis działa (lub już działał).
+ */
+bool services_timer_start(void);
+
+/**
+ * Zatrzymuje serwis timerów i usuwa wszystkie aktywne deadline'y.
+ */
+void services_timer_stop(void);
+
+/**
+ * Uzbraja timer one-shot, który po @p delay_us opublikuje zdarzenie @p (src,code,a0,a1).
+ *
+ * @note Zdarzenie musi być typu EVK_NONE albo EVK_COPY.
+ *
+ * @return token != 0 w przypadku sukcesu.
+ */
+services_timer_token_t services_timer_arm_once_us(uint64_t delay_us,
+                                                  ev_src_t src,
+                                                  uint16_t code,
+                                                  uint32_t a0,
+                                                  uint32_t a1);
+
+/**
+ * Uzbraja timer periodyczny, który będzie publikował zdarzenie co @p period_us.
+ * Pierwsze wyzwolenie następuje po @p period_us.
+ *
+ * @note Zdarzenie musi być typu EVK_NONE albo EVK_COPY.
+ *
+ * @return token != 0 w przypadku sukcesu.
+ */
+services_timer_token_t services_timer_arm_periodic_us(uint64_t period_us,
+                                                      ev_src_t src,
+                                                      uint16_t code,
+                                                      uint32_t a0,
+                                                      uint32_t a1);
+
+/**
+ * Anuluje timer.
+ *
+ * @return true jeśli timer został anulowany.
+ */
+bool services_timer_cancel(services_timer_token_t tok);
+
+/**
+ * Sprawdza czy token wskazuje aktywny timer.
+ */
+bool services_timer_is_active(services_timer_token_t tok);
 
 #ifdef __cplusplus
-}
+}  // extern "C"
 #endif
diff --git a/firmware/components/services__timer/services_timer.c b/firmware/components/services__timer/services_timer.c
index 16d579d..beb8fec 100644
--- a/firmware/components/services__timer/services_timer.c
+++ b/firmware/components/services__timer/services_timer.c
@@ -1,49 +1,414 @@
 #include "services_timer.h"
 
+#include "sdkconfig.h"
+
+#include <string.h>
+
 #include "core_ev.h"
-#include "esp_timer.h"
+#include "ports/clock_port.h"
+#include "ports/timer_port.h"
+
+#include "esp_log.h"
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+
+#ifndef CONFIG_SERVICES_TIMER_MAX_SLOTS
+#define CONFIG_SERVICES_TIMER_MAX_SLOTS 16
+#endif
+
+// Opcjonalnie: zachowaj stare EV_TICK_* jako periodyczne timery.
+#ifndef CONFIG_SERVICES_TIMER_ENABLE_LEGACY_TICKS
+#define CONFIG_SERVICES_TIMER_ENABLE_LEGACY_TICKS 0
+#endif
 
-static esp_timer_handle_t s_t100 = NULL;
-static esp_timer_handle_t s_t1s  = NULL;
+static const char* TAG = "SVC_TIMER";
 
-static void t100_cb(void* arg)
+typedef struct
 {
-    (void)arg;
-    ev_post(EV_SRC_TIMER, EV_TICK_100MS, 0, 0);
+    bool active;
+    uint16_t gen;
+    uint64_t due_us;
+    uint64_t period_us;  // 0 = one-shot
+
+    ev_src_t src;
+    uint16_t code;
+    uint32_t a0;
+    uint32_t a1;
+} svc_timer_slot_t;
+
+typedef struct
+{
+    ev_src_t src;
+    uint16_t code;
+    uint32_t a0;
+    uint32_t a1;
+} svc_timer_fire_t;
+
+static svc_timer_slot_t s_slots[CONFIG_SERVICES_TIMER_MAX_SLOTS];
+static timer_handle_t s_timer = NULL;
+static SemaphoreHandle_t s_mu = NULL;
+
+static bool s_started = false;
+static bool s_armed   = false;
+static uint64_t s_due_us = 0;
+
+static services_timer_token_t token_make_(unsigned idx, uint16_t gen)
+{
+    return ((services_timer_token_t)gen << 16) | (services_timer_token_t)(idx + 1u);
+}
+
+static bool token_parse_(services_timer_token_t tok, unsigned* out_idx, uint16_t* out_gen)
+{
+    const unsigned lo = (unsigned)(tok & 0xFFFFu);
+    if (lo == 0)
+        return false;
+
+    const unsigned idx = lo - 1u;
+    if (idx >= (unsigned)CONFIG_SERVICES_TIMER_MAX_SLOTS)
+        return false;
+
+    *out_idx = idx;
+    *out_gen = (uint16_t)((tok >> 16) & 0xFFFFu);
+    return true;
 }
-static void t1s_cb(void* arg)
+
+static uint64_t periodic_next_due_(uint64_t prev_due_us, uint64_t period_us, uint64_t now_us)
+{
+    uint64_t next = prev_due_us + period_us;
+
+    // Jeśli jesteśmy daleko w tyle (np. blokady), przeskocz do pierwszego terminu > now.
+    if (next <= now_us)
+    {
+        const uint64_t behind = now_us - next;
+        const uint64_t steps  = (behind / period_us) + 1u;
+        next += steps * period_us;
+    }
+
+    return next;
+}
+
+static bool find_earliest_due_locked_(uint64_t* out_due_us)
+{
+    bool found     = false;
+    uint64_t best  = 0;
+
+    for (unsigned i = 0; i < (unsigned)CONFIG_SERVICES_TIMER_MAX_SLOTS; i++)
+    {
+        if (!s_slots[i].active)
+            continue;
+        if (!found || (s_slots[i].due_us < best))
+        {
+            best  = s_slots[i].due_us;
+            found = true;
+        }
+    }
+
+    if (found)
+        *out_due_us = best;
+    return found;
+}
+
+static void arm_earliest_locked_(uint64_t now_us)
+{
+    uint64_t next_due_us = 0;
+
+    if (!find_earliest_due_locked_(&next_due_us))
+    {
+        if (s_armed)
+        {
+            (void)timer_cancel(s_timer);
+            s_armed  = false;
+            s_due_us = 0;
+        }
+        return;
+    }
+
+    if (s_armed && (next_due_us == s_due_us))
+        return;
+
+    uint64_t delay_us = (next_due_us > now_us) ? (next_due_us - now_us) : 1u;
+    if (delay_us == 0)
+        delay_us = 1u;
+
+    // Re-arm: cancel + start.
+    (void)timer_cancel(s_timer);
+
+    const port_err_t err = timer_start_oneshot(s_timer, delay_us);
+    if (err != ESP_OK)
+    {
+        ESP_LOGE(TAG, "timer_start_oneshot(%llu us) failed: %d", (unsigned long long)delay_us,
+                 (int)err);
+        s_armed  = false;
+        s_due_us = 0;
+        return;
+    }
+
+    s_armed  = true;
+    s_due_us = next_due_us;
+}
+
+static void timer_cb_(void* arg)
 {
     (void)arg;
-    ev_post(EV_SRC_TIMER, EV_TICK_1S, 0, 0);
+
+    svc_timer_fire_t fires[CONFIG_SERVICES_TIMER_MAX_SLOTS];
+    unsigned n_fires = 0;
+
+    const uint64_t now_us = clock_now_us();
+
+    if (!s_mu)
+        return;
+
+    xSemaphoreTake(s_mu, portMAX_DELAY);
+
+    // One-shot timer just fired.
+    s_armed  = false;
+    s_due_us = 0;
+
+    for (unsigned i = 0; i < (unsigned)CONFIG_SERVICES_TIMER_MAX_SLOTS; i++)
+    {
+        svc_timer_slot_t* s = &s_slots[i];
+        if (!s->active)
+            continue;
+
+        if (s->due_us > now_us)
+            continue;
+
+        // Emit once per slot.
+        if (n_fires < (unsigned)CONFIG_SERVICES_TIMER_MAX_SLOTS)
+        {
+            fires[n_fires++] = (svc_timer_fire_t){.src = s->src, .code = s->code, .a0 = s->a0, .a1 = s->a1};
+        }
+
+        if (s->period_us == 0)
+        {
+            s->active = false;
+        }
+        else
+        {
+            s->due_us = periodic_next_due_(s->due_us, s->period_us, now_us);
+        }
+    }
+
+    arm_earliest_locked_(now_us);
+
+    xSemaphoreGive(s_mu);
+
+    // Post outside the mutex.
+    for (unsigned i = 0; i < n_fires; i++)
+    {
+        ev_post(fires[i].src, fires[i].code, fires[i].a0, fires[i].a1);
+    }
 }
 
 bool services_timer_start(void)
 {
-    esp_timer_create_args_t a100 = {.callback = t100_cb, .name = "t100ms"};
-    esp_timer_create_args_t a1s  = {.callback = t1s_cb, .name = "t1s"};
-    if (esp_timer_create(&a100, &s_t100) != ESP_OK)
+    if (s_started)
+        return true;
+
+    s_mu = xSemaphoreCreateMutex();
+    if (!s_mu)
+    {
+        ESP_LOGE(TAG, "mutex alloc failed");
         return false;
-    if (esp_timer_create(&a1s, &s_t1s) != ESP_OK)
+    }
+
+    memset(s_slots, 0, sizeof(s_slots));
+    s_armed   = false;
+    s_due_us  = 0;
+    s_started = false;
+
+    const port_err_t err = timer_create(&s_timer, timer_cb_, NULL);
+    if (err != ESP_OK)
+    {
+        ESP_LOGE(TAG, "timer_create failed: %d", (int)err);
+        vSemaphoreDelete(s_mu);
+        s_mu = NULL;
         return false;
-    if (esp_timer_start_periodic(s_t100, 100000) != ESP_OK)
-        return false;  // 100ms
-    if (esp_timer_start_periodic(s_t1s, 1000000) != ESP_OK)
-        return false;  // 1s
+    }
+
+    s_started = true;
+
+#if CONFIG_SERVICES_TIMER_ENABLE_LEGACY_TICKS
+    // Legacy tick generator is implemented on top of the same scheduler.
+    (void)services_timer_arm_periodic_us(100000u, EV_SRC_TIMER, EV_TICK_100MS, 0, 0);
+    (void)services_timer_arm_periodic_us(1000000u, EV_SRC_TIMER, EV_TICK_1S, 0, 0);
+#endif
+
     return true;
 }
 
 void services_timer_stop(void)
 {
-    if (s_t100)
+    if (!s_started)
+        return;
+
+    xSemaphoreTake(s_mu, portMAX_DELAY);
+
+    if (s_timer)
+    {
+        (void)timer_cancel(s_timer);
+        (void)timer_delete(s_timer);
+        s_timer = NULL;
+    }
+
+    memset(s_slots, 0, sizeof(s_slots));
+    s_armed   = false;
+    s_due_us  = 0;
+    s_started = false;
+
+    xSemaphoreGive(s_mu);
+
+    vSemaphoreDelete(s_mu);
+    s_mu = NULL;
+}
+
+services_timer_token_t services_timer_arm_once_us(uint64_t delay_us, ev_src_t src, uint16_t code,
+                                                  uint32_t a0, uint32_t a1)
+{
+    if (!s_started || !s_mu || !s_timer)
+        return 0;
+
+    if (delay_us == 0)
+        delay_us = 1u;
+
+    const uint64_t now_us = clock_now_us();
+
+    xSemaphoreTake(s_mu, portMAX_DELAY);
+
+    unsigned slot = (unsigned)CONFIG_SERVICES_TIMER_MAX_SLOTS;
+    for (unsigned i = 0; i < (unsigned)CONFIG_SERVICES_TIMER_MAX_SLOTS; i++)
     {
-        esp_timer_stop(s_t100);
-        esp_timer_delete(s_t100);
-        s_t100 = NULL;
+        if (!s_slots[i].active)
+        {
+            slot = i;
+            break;
+        }
     }
-    if (s_t1s)
+
+    if (slot >= (unsigned)CONFIG_SERVICES_TIMER_MAX_SLOTS)
     {
-        esp_timer_stop(s_t1s);
-        esp_timer_delete(s_t1s);
-        s_t1s = NULL;
+        xSemaphoreGive(s_mu);
+        ESP_LOGW(TAG, "no free slots (max=%d)", CONFIG_SERVICES_TIMER_MAX_SLOTS);
+        return 0;
     }
+
+    svc_timer_slot_t* s = &s_slots[slot];
+    uint16_t gen        = (uint16_t)(s->gen + 1u);
+    if (gen == 0)
+        gen = 1;
+
+    *s = (svc_timer_slot_t){
+        .active    = true,
+        .gen       = gen,
+        .due_us    = now_us + delay_us,
+        .period_us = 0,
+        .src       = src,
+        .code      = code,
+        .a0        = a0,
+        .a1        = a1,
+    };
+
+    arm_earliest_locked_(now_us);
+    xSemaphoreGive(s_mu);
+
+    return token_make_(slot, gen);
+}
+
+services_timer_token_t services_timer_arm_periodic_us(uint64_t period_us, ev_src_t src, uint16_t code,
+                                                      uint32_t a0, uint32_t a1)
+{
+    if (!s_started || !s_mu || !s_timer)
+        return 0;
+
+    if (period_us == 0)
+        return 0;
+
+    const uint64_t now_us = clock_now_us();
+
+    xSemaphoreTake(s_mu, portMAX_DELAY);
+
+    unsigned slot = (unsigned)CONFIG_SERVICES_TIMER_MAX_SLOTS;
+    for (unsigned i = 0; i < (unsigned)CONFIG_SERVICES_TIMER_MAX_SLOTS; i++)
+    {
+        if (!s_slots[i].active)
+        {
+            slot = i;
+            break;
+        }
+    }
+
+    if (slot >= (unsigned)CONFIG_SERVICES_TIMER_MAX_SLOTS)
+    {
+        xSemaphoreGive(s_mu);
+        ESP_LOGW(TAG, "no free slots (max=%d)", CONFIG_SERVICES_TIMER_MAX_SLOTS);
+        return 0;
+    }
+
+    svc_timer_slot_t* s = &s_slots[slot];
+    uint16_t gen        = (uint16_t)(s->gen + 1u);
+    if (gen == 0)
+        gen = 1;
+
+    *s = (svc_timer_slot_t){
+        .active    = true,
+        .gen       = gen,
+        .due_us    = now_us + period_us,
+        .period_us = period_us,
+        .src       = src,
+        .code      = code,
+        .a0        = a0,
+        .a1        = a1,
+    };
+
+    arm_earliest_locked_(now_us);
+    xSemaphoreGive(s_mu);
+
+    return token_make_(slot, gen);
+}
+
+bool services_timer_cancel(services_timer_token_t tok)
+{
+    if (!s_started || !s_mu)
+        return false;
+
+    unsigned idx = 0;
+    uint16_t gen = 0;
+    if (!token_parse_(tok, &idx, &gen))
+        return false;
+
+    const uint64_t now_us = clock_now_us();
+
+    xSemaphoreTake(s_mu, portMAX_DELAY);
+
+    svc_timer_slot_t* s = &s_slots[idx];
+    if (!s->active || (s->gen != gen))
+    {
+        xSemaphoreGive(s_mu);
+        return false;
+    }
+
+    s->active = false;
+
+    arm_earliest_locked_(now_us);
+    xSemaphoreGive(s_mu);
+
+    return true;
+}
+
+bool services_timer_is_active(services_timer_token_t tok)
+{
+    if (!s_started || !s_mu)
+        return false;
+
+    unsigned idx = 0;
+    uint16_t gen = 0;
+    if (!token_parse_(tok, &idx, &gen))
+        return false;
+
+    xSemaphoreTake(s_mu, portMAX_DELAY);
+    const bool ok = s_slots[idx].active && (s_slots[idx].gen == gen);
+    xSemaphoreGive(s_mu);
+
+    return ok;
 }
diff --git a/firmware/projects/demo_hello_ev/main/main.c b/firmware/projects/demo_hello_ev/main/main.c
index f7d972f..e7d7ed8 100644
--- a/firmware/projects/demo_hello_ev/main/main.c
+++ b/firmware/projects/demo_hello_ev/main/main.c
@@ -1,6 +1,6 @@
 /**
  * @file main.c
- * @brief Minimalny przykład: event-bus + EV_TICK_1S/100MS + log.
+ * @brief Minimalny przykład: event-bus + deadline-driven timer (bez globalnego tick-spamu).
  */
 #include "core_ev.h"
 #include "ports/log_port.h"
@@ -18,6 +18,9 @@ void app_main(void)
     ev_queue_t q;
     ev_subscribe(&q, 16);
 
+    // Jawnie uzbrój „heartbeat” 1s – ticki nie są generowane automatycznie (domyślnie).
+    (void)services_timer_arm_periodic_us(1000000ULL, EV_SRC_TIMER, EV_TICK_1S, 0, 0);
+
     LOGI(TAG, "Start aplikacji (event-driven)");
 
     ev_post(EV_SRC_SYS, EV_SYS_START, 0, 0);

